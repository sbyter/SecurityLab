(* protocol 1 *)

type host.
type nonce.
type key. (* symetric key *)

free c: channel.
free A,B: host.



(* symetric encryption *)

fun senc(bitstring, key): bitstring.
reduc forall m: bitstring, k: key; sdec(senc(m,k),k) = m.

(* asymetric encryption *)
type pkey. (* public key *)
type skey. (* private key *)

fun pk(skey): pkey. (* unary constructor *)
fun aenc(bitstring, pkey): bitstring.
reduc forall m: bitstring, k: skey; adec(aenc(m, pk(k)), k) = m.

(* ------------------------------------------------------------------ *)
let clientA( A:host ) =
	out(c, A). (* 1: A->B *)

let clientB( Kbs:key, A:host, B:host, n_b:nonce ) =
	in(c, xA:bitstring);
	let (=A, y:bitstring) = xA in
	out(c, (B, senc((A, n_b), Kbs))).  (* 2a: B->S *)

let server( Kas:key, Kbs:key, Kab:key, A:host, B:host ) =	
	in(c, xB:bitstring); (* 2b receive *)
	let (=B, yB:bitstring) = xB in (* 2c: validate B *)
	let (=A, n_b:nonce) = sdec(yB, Kbs) in (* 2d: validate A *)
	out(c, (senc((B, n_b, Kab), Kas))). (* 3: S->A *)
	
process
	(* new skA: skey; new skB: skey; new skC: skey; *)
	(* let pkA = pk(skA) in let pkB = pk(skB) in let pkC = pk(skC) in *)
	(* out(c, pkA); out(c, pkB); out(c, skC); *)
	
	new Kas: key;
	new Kbs: key;
	(
	 (! clientA(A)) |
	 (! new n_b: nonce; clientB(Kbs, A, B, n_b)) |
	 (! new Kab: key; server(Kas, Kbs, Kab, A, B))
	)
